<!doctype html>

<header>
    <meta charset="utf-8">
    <title>Hello from Flask</title>
    <script src="/static/js/d3.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>

    <style>
        body { margin:0;position:fixed;top:0;right:0;bot:0;left:0; }
        /*svg { width:100%; height: 100% }*/

        path {
            fill: #d3d3d3;
            stroke: black;
            stroke-width: "2%";
        }

    </style>
</header>
<body>
  <h1>MAP!</h1>
  <div class="app" width='600px' height='400px'></div>

  <script type="text/javascript">
      var width = 600,
          height = 600;

      // var url = "/topoaachen";
      // var url = "/topodeu";
      // var url = "/deu";
      var url = "/static/deu_complex.topojson";
      // var url = "http://enjalot.github.io/wwsd/data/world/world-110m.geojson";

      d3.json(url, function(err, tj) {
        if (err) throw err;

        // tj = topojson.topology(tj.features);
        tj = topojson.presimplify(tj);
        geojson = topojson.feature( tj, tj.objects.primary );

        var svg = d3.select(".app")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .on("click", stopped, true);

            g = svg.append("g")

        // Determine a good projection to match the data
        var mapprojection = d3.geoMercator()
                              .fitExtent( [[0,0],[width,height]], geojson);
        
        var minZOriginal = 2/mapprojection.scale(), minZ = minZOriginal;
        
        tmp = mapprojection.invert([0,0])
        var top =tmp[1]
        var left=tmp[0]
        
        tmp = mapprojection.invert([width,height])
        var bot  =tmp[1]
        var right=tmp[0]

        var clipAndSimp = d3.geoTransform({point: function(x,y,z){ 
            if (y>top | y<bot | x<left |x>right){
                if (z>=100*minZOriginal){
                    return this.stream.point(x,y);
                }
            } else {
                if (z>=minZ){
                    return this.stream.point(x,y);
                }
            }
        }});
        
        var projection = {
              stream: function(s) {
                return clipAndSimp.stream(mapprojection.stream(s)); // WOOOOOW, javascript sucks...order is 
              }
            };

        // Make path mapper and create region instance
        path = d3.geoPath().projection(projection);

        var region = g.selectAll("path")
                      .data(geojson.features).enter()
                      .append("path")
                      .attr("d", path);

        // Add zooming and dragging
        var zoom = d3.zoom()
                     .on("zoom", zoomed);


        var lastZoom = 1;
        var lastXO = 0;
        var lastYO = 0;

        var pad = 300
        function recalculatePoints(t) {
            if ((Math.abs(1-t.k/lastZoom) > -0.01)  | 
                ( Math.abs(t.x/t.k - lastXO) > pad) | 
                ( Math.abs(t.y/t.k - lastYO) > pad)) {

                k = Math.max(1, Math.min(100, t.k));
                // console.log(t.k, k);
                lastZoom=t.k;
                lastXO = t.x/t.k;
                lastYO = t.y/t.k;

                var tmp = mapprojection.invert([(-pad-t.x)/t.k, (-pad-t.y)/t.k,])
                left=tmp[0]
                top =tmp[1]

                var tmp = mapprojection.invert([(pad+width-t.x)/t.k, (pad+height-t.y)/t.k,])
                right=tmp[0]
                bot  =tmp[1]

                minZ = minZOriginal / k;

                 g.selectAll("path").style("stroke-width", 1/k).attr("d", path);
            }
        }
        function zoomed(d) {
          var t = d3.event.transform;
          
          g.attr("transform", d3.event.transform);
          recalculatePoints(t);
        }



        svg.call(zoom);

      })

      // If the drag behavior prevents the default click,
      // also stop propagation so we donâ€™t click-to-zoom.
      function stopped() {
        if (d3.event.defaultPrevented) d3.event.stopPropagation();
      }


  </script>
</body>